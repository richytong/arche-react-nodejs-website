#!/usr/bin/env node

require('rubico/global')
const http = require('http')
const { spawn } = require('child_process')
const StaticCache = require('./StaticCache')
const ServePage = require('./ServePage')

const serve = async function (options) {
  const {
    port,
    htmlServerPort,
    htmlServerNoCache,
  } = options

  {
    const cmd = spawn('node', [`${__dirname}/html-server/index.mjs`], {
      env: {
        ...process.env,
        NODE_ENV: process.env.NODE_ENV,
        PORT: htmlServerPort,
        NO_CACHE: htmlServerNoCache,
      },
    })
    cmd.stdout.pipe(process.stdout)
    cmd.stderr.pipe(process.stderr)

    cmd.on('close', code => {
      console.error('HTML Server closed with code', code)
      process.exit(code)
    })

    cmd.on('error', error => {
      console.error(error)
      process.exit(1)
    })

    process.on('exit', () => {
      cmd.kill()
    })
  }

  const publicCache = new StaticCache({
    directory: `${__dirname}/public`,
  });
  await publicCache.load()

  const servePage = ServePage({
    htmlServerPort,
    publicCache,
  })

  const server = http.createServer(async (request, response) => {
    await servePage(request, response).catch(error => {
      console.error(error)
      if (typeof error.code != 'number') {
        error.code = 500
      }
      response.writeHead(error.code, {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'text/plain',
      })
      response.end(error.message)
    })
  })

  server.listen(port, () => {
    console.log(`server listening on port ${port}`)
  })
}

if (process.argv[1] == __filename) {
  serve({
    port: process.env.PORT,
    htmlServerPort: process.env.HTML_SERVER_PORT,
  })
}

module.exports = serve
